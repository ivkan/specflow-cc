# SPEC: Subagent-Based Execution Model

> **SPLIT:** This specification was decomposed into:
> - SPEC-SUBAGENT-A: Foundation — Auditor Enhancement & Template Changes
> - SPEC-SUBAGENT-B: Core Agent Architecture — Orchestrator & Worker
> - SPEC-SUBAGENT-C: State Management & Reliability
>
> See child specifications for implementation.

---
id: SPEC-SUBAGENT
type: feature
status: split
priority: high
complexity: large
created: 2026-01-23
split_into: [SPEC-SUBAGENT-A, SPEC-SUBAGENT-B, SPEC-SUBAGENT-C]
---

## Context

### Problem Statement

Current `spec-executor` runs in a **single context** that accumulates:
1. Full specification (~100-500 lines)
2. PROJECT.md context (~50-100 lines)
3. Multiple file reads (potentially thousands of lines)
4. Implementation code written
5. Todo tracking, thinking, tool calls history

**Result**: Large specifications (like SPEC-001 with 28 message handlers, 11 new files, editing a 4858-line file) exhaust context before completion → "Prompt is too long" error.

### GSD Solution Analysis

GSD solves this with a **two-tier execution model**:

```
┌─────────────────────────────────────┐
│  ORCHESTRATOR (~10-15% context)     │
│  - Reads plan metadata only         │
│  - Parses tasks into waves          │
│  - Spawns parallel subagents        │
│  - Aggregates results               │
│  - Never reads implementation files │
└─────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────┐
│  WORKER SUBAGENTS (fresh 200k each) │
│  - Receives specific task(s)        │
│  - Full context for that task       │
│  - Implements, commits, returns     │
│  - Isolated from other workers      │
└─────────────────────────────────────┘
```

**Key principles from GSD:**
- 2-3 tasks per worker maximum
- ~50% context target, never >70%
- Wave-based parallelization for independent tasks
- Orchestrator stays lean, delegates heavy work
- Fresh context = fresh quality

## Task

Implement a **subagent-based execution model** for SpecFlow that:
1. Analyzes specification complexity before execution
2. Decomposes requirements into executable task groups
3. Executes task groups via dedicated subagents
4. Coordinates results and maintains atomic commits
5. Handles failures gracefully with resumption capability

## Requirements

### Phase 1: Specification Task Decomposition

#### 1.1 Enhance Spec Template

Add optional `## Implementation Tasks` section to spec template:

```markdown
## Implementation Tasks

> Auto-generated by auditor or executor. Manual override allowed.

### Task Groups

| Group | Tasks | Dependencies | Est. Context |
|-------|-------|--------------|--------------|
| G1 | Create types.ts interfaces | — | ~15% |
| G2 | Create partition-handler.ts | G1 | ~20% |
| G3 | Create topic-handler.ts | G1 | ~20% |
| G4 | Wire handlers in ServerCoordinator | G2, G3 | ~25% |

### Execution Plan

```
Wave 1 (parallel): G1
Wave 2 (parallel): G2, G3
Wave 3 (sequential): G4
```
```

#### 1.2 Auditor Enhancement

Modify `spec-auditor.md` to add **Execution Scope Check**:

```markdown
### Execution Scope Check

Evaluate execution complexity:

| Metric | Value | Threshold | Status |
|--------|-------|-----------|--------|
| Files to create | {N} | ≤5 | ✓/⚠/✗ |
| Files to modify | {N} | ≤3 | ✓/⚠/✗ |
| Target file max LOC | {N} | ≤1000 | ✓/⚠/✗ |
| Acceptance criteria | {N} | ≤10 | ✓/⚠/✗ |
| Total requirements | {N} | ≤15 | ✓/⚠/✗ |

**Estimated context usage:** {small: ~30% | medium: ~50% | large: ~80%+}

**Thresholds:**
- ✓ OK: Within limits
- ⚠ Warning: At limit, may need careful execution
- ✗ Exceeded: MUST split or use multi-agent execution

**If large (>50% estimated):**
- Generate Implementation Tasks section
- Recommend `/sf:run --parallel` mode
```

**New audit status:** `NEEDS_DECOMPOSITION` (between APPROVED and NEEDS_SPLIT)

### Phase 2: New Agent Architecture

#### 2.1 Create `spec-executor-orchestrator.md`

New agent that coordinates execution without doing implementation:

```markdown
---
name: sf-spec-executor-orchestrator
description: Orchestrates parallel execution of specification tasks
tools: Read, Write, Bash, Task, Glob
---

<role>
You are a SpecFlow execution orchestrator. You coordinate implementation
across multiple worker subagents without implementing code yourself.

Your job is to:
1. Parse specification into task groups
2. Determine execution waves (dependencies)
3. Spawn worker subagents in parallel where possible
4. Aggregate results and handle failures
5. Create final execution summary
</role>

<philosophy>

## Context Budget

You are the ORCHESTRATOR. Your context must stay under 20%:
- Read ONLY frontmatter and task sections of specs
- NEVER read implementation files (workers do that)
- NEVER write code (workers do that)
- Aggregate results from workers, don't reprocess

## Wave Execution

Tasks with no interdependencies execute in parallel:

```
Wave 1: [Task A, Task B, Task C] → parallel Task() calls
         ↓ all complete
Wave 2: [Task D (needs A), Task E (needs B,C)] → parallel
         ↓ all complete
Wave 3: [Task F (needs D,E)] → single Task() call
```

## Worker Protocol

Each worker receives:
- Specific task(s) from one group
- Relevant spec sections only (not full spec)
- PROJECT.md for patterns
- Clear deliverables list

Worker returns:
- Files created/modified
- Commits made
- Acceptance criteria addressed
- Any deviations

</philosophy>

<process>

## Step 1: Parse Task Groups

Read specification's `## Implementation Tasks` section.
If missing, generate task groups from Requirements:

```
Parse requirements → Group by dependency → Estimate context per group
```

**Grouping rules:**
- Types/interfaces → Group 1 (foundation)
- Independent handlers → Separate groups (parallel)
- Integration/wiring → Final group (depends on all)

## Step 2: Build Dependency Graph

```
G1 (types) ──┬──> G2 (handler-a)
             ├──> G3 (handler-b)
             └──> G4 (handler-c)
                      │
G2, G3, G4 ──────────>G5 (wiring)
```

## Step 3: Plan Waves

```
Wave 1: G1
Wave 2: G2, G3, G4 (parallel)
Wave 3: G5
```

## Step 4: Execute Waves

For each wave:

### 4.1 Parallel Spawn

```
Task(prompt="
<task_group>G2: Create partition-handler.ts</task_group>

<requirements>
{Extract only G2-relevant requirements from spec}
</requirements>

<interfaces>
{Types created in G1 - read from created files}
</interfaces>

<project_patterns>
@.specflow/PROJECT.md
</project_patterns>

Implement this task group. Create atomic commits.
Return: files_created, commits, criteria_met, deviations
", subagent_type="sf-spec-executor-worker", description="Execute G2")

Task(prompt="...G3...", subagent_type="sf-spec-executor-worker", description="Execute G3")

Task(prompt="...G4...", subagent_type="sf-spec-executor-worker", description="Execute G4")
```

**All three run in parallel** (single message, multiple Task calls).

### 4.2 Collect Results

Each worker returns structured result:
```json
{
  "group": "G2",
  "status": "complete|partial|failed",
  "files_created": ["path/to/file.ts"],
  "files_modified": [],
  "commits": ["abc123", "def456"],
  "criteria_met": ["Criterion 1", "Criterion 2"],
  "deviations": [],
  "error": null
}
```

### 4.3 Handle Failures

If worker fails:
- Log failure details
- If blocking: pause execution, report to user
- If non-blocking: continue, mark for retry

## Step 5: Aggregate Summary

Combine all worker results:
- Total files created/modified/deleted
- Total commits
- All criteria addressed
- All deviations

## Step 6: Finalize

- Append Execution Summary to spec
- Update STATE.md → "review"
- Report completion

</process>
```

#### 2.2 Create `spec-executor-worker.md`

Lightweight worker that implements specific task group:

```markdown
---
name: sf-spec-executor-worker
description: Implements specific task group from specification
tools: Read, Write, Edit, Bash, Glob, Grep
---

<role>
You are a SpecFlow execution worker. You implement a specific task group
with full focus and fresh context.

Your job is to:
1. Implement assigned task(s) precisely
2. Create atomic commits for each logical unit
3. Return structured results to orchestrator
</role>

<philosophy>

## Focused Execution

You receive ONLY your task group's requirements.
Implement exactly what's specified, nothing more.

## Deviation Rules

Same as spec-executor:
- Rule 1: Auto-fix bugs
- Rule 2: Auto-add missing critical functionality
- Rule 3: Auto-fix blocking issues
- Rule 4: Ask about architectural changes (STOP)

## Output Protocol

Return structured JSON at end:
```json
{
  "group": "{group_id}",
  "status": "complete",
  "files_created": [...],
  "files_modified": [...],
  "commits": [...],
  "criteria_met": [...],
  "deviations": [...]
}
```

</philosophy>

<process>

## Step 1: Understand Task

Parse provided:
- Task group ID and description
- Specific requirements
- Interfaces/types to use
- Project patterns

## Step 2: Implement

For each task in group:
1. Read relevant existing files
2. Implement requirement
3. Verify compilation/syntax
4. Commit: `feat(sf-XXX): {description}`

## Step 3: Return Results

Output structured result for orchestrator.

</process>
```

### Phase 3: Modified `/sf:run` Command

#### 3.1 Add Execution Mode Detection

```markdown
## Step 5.5: Determine Execution Mode

Check specification complexity:

**If Implementation Tasks section exists:**
- Count task groups
- Check for parallel opportunities
- If groups > 1 with parallelism → use orchestrator mode

**If no Implementation Tasks but large spec:**
- Estimate complexity from Requirements
- If estimated context > 50% → auto-generate tasks, use orchestrator

**Execution modes:**
- `single`: Traditional spec-executor (default for small specs)
- `orchestrated`: Parallel subagent execution (for large specs)

Display mode selection:
```
**Execution Mode:** orchestrated (5 task groups, 3 waves)

Estimated context per worker: ~25%
Parallelization: Wave 2 runs 3 workers simultaneously
```
```

#### 3.2 Orchestrator Spawn

```markdown
## Step 7: Spawn Executor

**If mode == "single":**
```
Task(prompt="...", subagent_type="sf-spec-executor", ...)
```

**If mode == "orchestrated":**
```
Task(prompt="
<specification>
@.specflow/specs/SPEC-XXX.md
</specification>

<project_context>
@.specflow/PROJECT.md
</project_context>

Orchestrate execution of this specification using parallel workers.
Follow spec-executor-orchestrator process.
", subagent_type="sf-spec-executor-orchestrator", description="Orchestrate execution")
```
```

### Phase 4: State Management for Resumption

#### 4.1 Execution State File

Create `.specflow/execution/SPEC-XXX-state.json`:

```json
{
  "spec_id": "SPEC-001",
  "mode": "orchestrated",
  "started": "2026-01-23T14:30:00Z",
  "waves": [
    {
      "id": 1,
      "groups": ["G1"],
      "status": "complete",
      "results": {...}
    },
    {
      "id": 2,
      "groups": ["G2", "G3", "G4"],
      "status": "in_progress",
      "results": {
        "G2": {...},
        "G3": "running",
        "G4": {...}
      }
    },
    {
      "id": 3,
      "groups": ["G5"],
      "status": "pending"
    }
  ],
  "commits": ["abc123", "def456", "..."],
  "last_checkpoint": "2026-01-23T14:45:00Z"
}
```

#### 4.2 Resumption Command

Add `/sf:run --resume` option:

```markdown
## Resume Mode

If execution state exists:
```
Found interrupted execution for SPEC-XXX

**Progress:**
- Wave 1: ✓ Complete (G1)
- Wave 2: ⚡ In Progress
  - G2: ✓ Complete
  - G3: ✗ Failed (context limit)
  - G4: ✓ Complete
- Wave 3: ○ Pending (G5)

Resume from G3?
```

Options:
- "Yes, resume G3" → spawn worker for G3 only
- "Restart Wave 2" → re-run all Wave 2 groups
- "Abort" → clean up, mark failed
```

### Phase 5: Quality Gates

#### 5.1 Pre-Wave Verification

Before each wave:
```
Verify prerequisites:
- Previous wave commits exist in git
- Created files are readable
- No syntax errors in dependencies
```

#### 5.2 Post-Wave Verification

After each wave:
```
Verify deliverables:
- All expected files created
- Git commits match expected count
- No uncommitted changes left
```

## Files to Create

| File | Purpose |
|------|---------|
| `agents/spec-executor-orchestrator.md` | Orchestrator agent |
| `agents/spec-executor-worker.md` | Worker agent |
| `templates/execution-state.json` | State schema |

## Files to Modify

| File | Changes |
|------|---------|
| `agents/spec-auditor.md` | Add Execution Scope Check, NEEDS_DECOMPOSITION status |
| `commands/sf/run.md` | Add mode detection, orchestrator spawn, resume support |
| `templates/spec.md` | Add Implementation Tasks section |
| `templates/state.md` | Add execution tracking fields |

## Acceptance Criteria

1. **Small specs unchanged**: Specs with ≤5 files, ≤10 requirements use single executor
2. **Large specs auto-decomposed**: Specs exceeding thresholds get task groups generated
3. **Parallel execution works**: Independent task groups run simultaneously
4. **Context stays bounded**: Each worker uses ≤50% context
5. **Resumption works**: Interrupted execution can resume from last checkpoint
6. **Commits remain atomic**: Each task produces meaningful commit(s)
7. **Results aggregated correctly**: Final summary reflects all workers' output
8. **Failures handled gracefully**: Single worker failure doesn't lose other work

## Constraints

- DO NOT change behavior for small/medium specs
- DO NOT require manual task decomposition (auto-generate)
- DO NOT break existing spec-executor for simple cases
- DO NOT spawn workers for single-task specs

## Implementation Order

1. **Phase 1** (Foundation): Auditor enhancement + spec template changes
2. **Phase 2** (Core): Create orchestrator and worker agents
3. **Phase 3** (Integration): Modify /sf:run with mode detection
4. **Phase 4** (Reliability): State management and resumption
5. **Phase 5** (Quality): Pre/post wave verification

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        /sf:run                                   │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │
│  │ Load Spec   │───>│ Check Size  │───>│ Select Mode         │  │
│  └─────────────┘    └─────────────┘    └─────────────────────┘  │
│                                               │                  │
│                          ┌────────────────────┼──────────────┐   │
│                          ▼                    ▼              │   │
│                    ┌──────────┐        ┌─────────────┐       │   │
│                    │ SINGLE   │        │ ORCHESTRATED│       │   │
│                    │ MODE     │        │ MODE        │       │   │
│                    └────┬─────┘        └──────┬──────┘       │   │
│                         │                     │              │   │
│                         ▼                     ▼              │   │
│                 ┌───────────────┐    ┌────────────────┐      │   │
│                 │spec-executor  │    │orchestrator    │      │   │
│                 │(traditional)  │    │(~15% context)  │      │   │
│                 └───────────────┘    └───────┬────────┘      │   │
│                                              │               │   │
│                            ┌─────────────────┼─────────────┐ │   │
│                            ▼                 ▼             ▼ │   │
│                     ┌──────────┐      ┌──────────┐  ┌──────────┐ │
│                     │ Worker   │      │ Worker   │  │ Worker   │ │
│                     │ G1       │      │ G2       │  │ G3       │ │
│                     │(~25%)    │      │(~25%)    │  │(~25%)    │ │
│                     └────┬─────┘      └────┬─────┘  └────┬─────┘ │
│                          │                 │             │       │
│                          └────────┬────────┴─────────────┘       │
│                                   ▼                              │
│                          ┌────────────────┐                      │
│                          │ Aggregate      │                      │
│                          │ Results        │                      │
│                          └────────────────┘                      │
│                                   │                              │
│                                   ▼                              │
│                          ┌────────────────┐                      │
│                          │ Execution      │                      │
│                          │ Summary        │                      │
│                          └────────────────┘                      │
└─────────────────────────────────────────────────────────────────┘
```

## Comparison: Before vs After

| Aspect | Before | After |
|--------|--------|-------|
| Context per spec | 100% (single agent) | ~15% orchestrator + ~25% per worker |
| Large spec handling | Fails at context limit | Completes via workers |
| Parallelism | None | Waves run in parallel |
| Failure recovery | Start over | Resume from checkpoint |
| Small spec overhead | None | None (single mode) |

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Worker coordination overhead | Orchestrator stays minimal, workers are autonomous |
| Git conflicts between workers | Wave-based: no parallel writes to same file |
| Lost context between workers | Each worker gets necessary context in prompt |
| Debugging complexity | Execution state JSON tracks all progress |

## Notes

- GSD uses "gsd-executor" which is similar to our proposed worker
- GSD's orchestrator in execute-phase.md provides good reference
- Wave-based approach proven in production at scale
- Context budget targeting (~50%) is key to quality maintenance
